[{"name":"app.R","content":"\n# \n# UNLOAD ALL PACKAGES\n# \n# pacman::p_unload(pacman::p_loaded(), character.only = TRUE) \n# \n# INSTALL VERSIONS KORPUS CONSISTENT WITH WEBR\n#\n# remotes::install_version(\"koRpus\", version = \"0.13-8\")\n# remotes::install_version(\"koRpus.lang.en\", version = \"0.1-4\")\n# \n# IN CASE RSCONNECT IS SPECIFIED\n# \n# remove.packages(\"rsconnect\")\n# \n# THEN\n# \n# shinylive::export(appdir = \".\", destdir = \"docs\")\n# httpuv::runStaticServer(\"docs/\", port = 8008)\n\nlibrary(shiny)\nlibrary(DT) # To create a datatable\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(udpipe) # Part-of-speech-tagger\nlibrary(textcat) # To detect the language of a text\nlibrary(zoo) # For the time series analysis.\nlibrary(koRpus) # To obtain lexical diversity measures\nlibrary(koRpus.lang.en) # Corpus English Language\nlibrary(colourpicker) # to select lovely colours\n\n# if (FALSE) { # Needed to autoload these libraries\n# }\n\ncolours_text = \"Word_class,scheme1,scheme2,scheme3,scheme4\nVERB,#FFAB94,#FFAB94,#FFFFFF,#FFFFFF\nCOPULA,#FFAB94,#FFAB94,#FFFFFF,#FFFFFF\nAUXILIARY,#FAD4CB,#FAD4CB,#FFFFFF,#FFFFFF\nPARTICLE,#FAD4CB,#FAD4CB,#FFFFFF,#FFFFFF\nADVB,#FAD4CB,#FAD4CB,#FFFFFF,#FFFFFF\nNOUN,#B6B6F5,#FFFFFF,#B6B6F5,#FFFFFF\nDET,#ADFFFF,#FFFFFF,#ADFFFF,#FFFFFF\nADJ,#ADFFFF,#FFFFFF,#ADFFFF,#FFFFFF\nPRON,#99FF69,#FFFFFF,#99FF69,#FFFFFF\nPREP,#FFFF52,#FFFFFF,#FFFFFF,#FFFF52\nSUB,#FCAD46,#FFFFFF,#FFFFFF,#FCAD46\nCOORD,#FFCD7D,#FFFFFF,#FFFFFF,#FFCD7D\nPUNCT,#eeeedd,#FFFFFF,#FFFFFF,#FFFFFF\nINTERJECTION,#C29A72,#FFFFFF,#FFFFFF,#FFFFFF\"\n\ncolours <- read.table(text = colours_text, sep =\",\", header = TRUE, comment.char = \"\", stringsAsFactors = FALSE)\n\n# \nage_calc2 = function(dob, dot){\n  \n  dob_day = as.numeric(strftime(dob, \"%d\"))\n  dob_month = as.numeric(strftime(dob, \"%m\"))\n  dob_year = as.numeric(strftime(dob, \"%Y\"))\n  \n  dot_day = as.numeric(strftime(dot, \"%d\"))\n  dot_month = as.numeric(strftime(dot, \"%m\"))\n  dot_year = as.numeric(strftime(dot, \"%Y\"))\n  \n  years_diff = dot_year - dob_year\n  months_diff = dot_month - dob_month\n  days_diff = dot_day - dob_day\n  \n  total_months_diff = (years_diff*12) + (months_diff) + (days_diff/31)\n  \n  return(total_months_diff)\n}\n\n\nfill = function(df, varName){\n  varPosn = which(names(df) == varName)\n  vector = df[,varPosn]\n  fill_variable = \"\"\n  for(i in 1:length(vector)){\n    if(!is.na(vector[i])){\n      fill_variable = vector[i]\n    }\n    if(is.na(vector[i])){\n      vector[i] = fill_variable\n    }\n  }\n  return(vector)\n}\n\nshinyApp(\n  \n  ui <- fluidPage(#theme = \"flatly.css\",\n    \n    # Instructions page ----\n    navbarPage(\"MiMo\",\n               # Let's get started navbar ----\n               navbarMenu(\"ðŸ Let's get started!\",\n                          #(1) Enter text tab panel ----\n                          tabPanel(\"(1) Enter text\",\n                                   radioButtons(\"paste_or_upload\",\n                                                label = h3(\"Do you wish to paste or upload your data?\"),\n                                                choices = list(\"Paste\" = 1, \"Upload (.txt file only)\" = 2),\n                                                width = '100%', selected = 1),\n                                   conditionalPanel(condition = \"input.paste_or_upload == 1\",\n                                                    textAreaInput(\"text_file_TA\", \"Enter text here...\",\n                                                                  placeholder = \"Enter text here...\",\n                                                                  width = \"100%\", height = \"400px\", resize = \"both\"\n                                                    )\n                                   ),\n                                   conditionalPanel(condition = \"input.paste_or_upload == 2\",\n                                                    fileInput(\"text_file\", \"Select file\",\n                                                              multiple = FALSE,\n                                                              accept = c(\"text/plain\")\n                                                    )\n                                   ),\n                          ),\n                          #(2) Check language tab panel ----\n                          tabPanel(\"(2) Check language\",\n                                   htmlOutput(\"text_example\"),\n                                   radioButtons(\"proceed\", label = h3(\"How do you wish to proceed?\"),\n                                                choices = list(\"Continue\" = 1, \"Select another language\" = 2), \n                                                width = '100%', selected = 1),\n                                   conditionalPanel(condition = \"input.proceed == 2\",\n                                                    textAreaInput(\"manual_language\", \"Enter a language...\",\n                                                                  placeholder = \"Enter language name here...\",\n                                                                  width = \"1000px\", resize = \"both\"),\n                                                    textAreaInput(\"manual_url\", \"(OPTIONAL) Choose model...\",\n                                                                  placeholder = \"For a list of models, see section on udpipe_download_model in the R udpipe manual at https://cran.r-project.org/web/packages/udpipe/index.html\",\n                                                                  width = \"1000px\", resize = \"both\")\n                                   )\n                          )\n               ),\n               # Let's explore nav bar ----\n               navbarMenu(\"ï¸âœˆï¸ Let's explore!\",\n                          #(1) coloured output tab panel ----\n                          tabPanel(\"(1) Coloured output\",\n                                   \n                                   tags$head(\n                                     tags$style(HTML({\"\n                                       .mytooltip {\n                                       position: relative;\n                                       display: inline-block;\n                                       }\n                                       \n                                       .mytooltip .tooltiptext {\n                                       visibility: hidden;\n                                       width: 120px;\n                                       background-color: #ac3973;\n                                       color: #fff;\n                                       text-align: center;\n                                       border: 2px solid #df9fbf;\n                                       border-radius: 6px\n                                       padding: 5px 0;\n\n                                       \n                                       /* Position the tooltip */\n                                       position: absolute;\n                                       z-index: 1;\n                                       bottom: 100%;\n                                       left: 50%;\n                                       margin-left: -60px;\n                                       }\n                                       \n                                       .mytooltip:hover .tooltiptext {\n                                       visibility: visible;\n                                       }\n\n                                       \"}))\n                                   ),\n                                   \n                                   \n                                   h4(\"Table may take a few seconds to appear/refresh...\"),\n                                   DT::dataTableOutput(\"table_coloured\")\n                          ),\n                          \n                          \n                          \n                          #(2) Syntactic measures tab panel-----\n                          tabPanel(\"(2) Syntactic measures\",\n                                   h3(\"Syntactic measures\"),\n                                   DT::dataTableOutput(\"table_summaries\"),\n                                   br()\n                          ),  # end of tab panel ----\n                          \n                          \n                          \n                          \n                          \n                          #(3) Lexical measures tab panel-----\n                          tabPanel(\"(3) Lexical measures\",\n                                   h3(\"Lexical measures\"),\n                                   DT::dataTableOutput(\"table_summaries2\")\n                          ), # end of tab panel\n                          \n                          \n                          #(4) Tags -----\n                          tabPanel(\"(4) Tags\",\n                                   \n                                   mainPanel(\n                                     h4(\"Number of tags per utterance\"),\n                                     DT::dataTableOutput(\"tag_table_v1\"),\n                                     br(),\n                                     h4(\"Percentage of utterances containing a specific tag\"),\n                                     DT::dataTableOutput(\"tag_table_v2\")\n                                   )\n                                   \n                          ) # end of tags tabpanel\n                          \n                          \n                          \n               ), # end of nav bar menu\n               \n               \n               # Colour tab panel----\n               tabPanel(\"ðŸŒˆ Colours\", \n                        \n                        selectInput(inputId = \"colour_scheme\",\n                                    label = h3(\"Select colour scheme\"), \n                                    choices = list(\"All colours\" = 2,\n                                                   \"Verb-related words only\" = 3,\n                                                   \"Noun-related words only\" = 4,\n                                                   \"Linking words (conjunctions and Prepositions)\" = 5), \n                                    selected = 2),\n                        \n                        h3(\"Widgets contain hexadecimal colour codes.\n                                   Colours may be conveniently copied and pasted by copying and pasting these codes.\"),\n                        \n                        br(),\n                        h3(\"Word classes in the Verb Complex (sometimes called Verb Phrase)\"),\n                        htmlOutput(\"colour_picker_verb\"),\n                        htmlOutput(\"colour_picker_copula\"),\n                        htmlOutput(\"colour_picker_auxiliary\"),\n                        htmlOutput(\"colour_picker_particle\"),\n                        htmlOutput(\"colour_picker_advb\"),\n                        br(),\n                        h3(\"Word classes in the Noun Phrase\"),\n                        htmlOutput(\"colour_picker_noun\"),\n                        htmlOutput(\"colour_picker_det\"),\n                        htmlOutput(\"colour_picker_adj\"),\n                        htmlOutput(\"colour_picker_pron\"),\n                        br(),\n                        h3(\"Linking words\"),\n                        htmlOutput(\"colour_picker_prep\"),\n                        htmlOutput(\"colour_picker_sub\"),\n                        htmlOutput(\"colour_picker_coord\"),\n                        br(),\n                        h3(\"Other\"),\n                        htmlOutput(\"colour_picker_punct\"),\n                        htmlOutput(\"colour_picker_interjection\")\n                        \n                        \n               ), # End of tabPanel \"Colors\"\n               \n               \n               # Extra... nav bar ----\n               # navbarMenu(\"Copy and Paste\",\n               # Coloured output CnP ----\n               tabPanel(\"ðŸŽ¨ Copy and Paste\",\n                        h3(\"This table can be copied and pasted into a Word Processor Document, e.g. Microsoft Word\"),\n                        \n                        h3(\"Table will take a few seconds to appear/refresh...\"),\n                        DT::dataTableOutput(\"table_coloured_reduced\")\n               ), # end of Tab Panel\n    ) # end of nav bar page\n  ),\n  \n  # server statement----\n  server <- function(input, output, session){\n    \n    # ***REACTIVE STATEMENTS*** ----\n    # text (read in text file) ----\n    \n    text <- reactive({\n      \n      \n      if(is.null(input$text_file) & input$text_file_TA==\"\") return(NULL)\n      \n      \n      if(is.null(input$text_file)==FALSE){\n        text <- read.delim(input$text_file$datapath)$text\n      }\n      \n      if(input$text_file_TA!=\"\"){\n        text <- input$text_file_TA\n      }\n      # \n      \n      return(text)\n      \n    })\n    \n    \n    \n    \n    # lang (obtaining language) ----\n    \n    lang <- reactive({\n      \n      if(is.null(input$text_file) & input$text_file_TA==\"\") return(NULL)\n      \n      if(is.null(input$text_file)==FALSE){\n        text <- read.delim(input$text_file$datapath)$text\n      }\n      \n      if(input$text_file_TA!=\"\"){\n        text <- input$text_file_TA\n      }\n      \n      \n      lang <- textcat(text)\n      \n      return(lang)\n      \n    })\n    \n    \n    \n    # table (showing transcript)----\n    \n    table <- reactive({\n      \n      if(is.null(input$text_file) & input$text_file_TA==\"\") return(NULL)\n      \n      if(is.null(input$text_file)==FALSE){\n        text <- read.delim(input$text_file$datapath)$text\n      }\n      \n      if(input$text_file_TA!=\"\"){\n        text <- input$text_file_TA\n      }\n      \n      \n      \n      if(input$manual_language==\"\"){\n        lang <- textcat(text)} else{\n          lang <- input$manual_language\n        }\n      \n      lang <- trimws(tolower(lang))\n      \n      str_split_keep_delimiter <- function(string, delV){ #string and delimiter vector\n        for(i in 1:length(delV)){\n          search_string <- paste0(\"(\", delV[i], \")\")\n          replace_string <- \"\\\\1***\"\n          string <- str_replace_all(string, search_string, replace_string)\n        }\n        string <- str_split(string, \"[\\x2a][\\x2a][\\x2a]\")\n        string <- unlist(string)\n        string <- string[which(string != \"\")] # removes any blanks which may have been created\n        return(string)\n      }\n      \n      # Convert text object to vector\n      \n      alphanumeric <- function(x){\n        return(grepl(\"[a-zA-Z0-9]\",x))\n      }\n      \n      \n      text <- str_split_keep_delimiter(text, c(\"[\\x2e]+[\\x22|\\x27]*[\\x20]*([\\\\[|\\x28][^\\\\[|\\x28]*[\\\\]|\\x29][\\x20]*)*\",\n                                               \"[\\x21]+[\\x22|\\x27]*[\\x20]*([\\\\[|\\x28][^\\\\[|\\x28]*[\\\\]|\\x29][\\x20]*)*\",\n                                               \"[\\x3f]+[\\x22|\\x27]*[\\x20]*([\\\\[|\\x28][^\\\\[|\\x28]*[\\\\]|\\x29][\\x20]*)*\")\n      )\n      \n      \n      \n      text <- as.data.frame(text)\n      \n      text <- text %>% filter(alphanumeric(text) == TRUE) # Gets rid of blank lines / lines with only punctuation\n      text$text <- str_trim(text$text) # Trims lead/trailing spaces\n      \n      extract_speaker <- function(x){ \n        x <- str_trim(x) # trim leading and trailing spaces\n        x <- strsplit(x, \" \")[[1]][1] # split by space and identify first word\n        x <- stringr::str_match(x, \"[a-zA-Z]+[\\x3a]$\") # identify whether first word could be speaker\n        return(x)\n      }\n      \n      remove_speaker <- function(x){ \n        x <- gsub(\"[a-zA-Z]+[\\x3a]\", \"\", x) # replace speaker with \"\"\n        return(x)\n      }\n      \n      text$speaker <- sapply(text$text, extract_speaker)\n      \n      # browser()\n      \n      text$speaker = fill(text, \"speaker\")\n      \n      text$speaker[which(is.na(text$speaker))] <- \"xxx:\"\n      \n      speakers <- text$speaker\n      \n      text$text <- sapply(text$text, remove_speaker)\n      \n      #Remove standalone punctation\n      \n      text$text <- gsub(\"[\\x20][:punct:][\\x20]\", \"\", text$text) # needs to be changed\n      \n      # Calculate Num Words - using spaces to delimit words\n      \n      count_words_using_spaces <- function(x){\n        return(str_count(x, \"[^\\x20]+\"))\n      }\n      \n      remove_non_alphanumeric <- function(x){\n        return(gsub(\"[^\\x20a-zA-Z0-9]\", \"\", x))\n      }\n      \n      extract_comments_as_vector <- function(x){\n        result <- unlist(str_extract_all(x, \"[\\x28][^\\x28|\\x29]*[\\x29]\"))\n        result <- paste0(\"\", result)\n        result <- as.vector(result)\n        return(result)\n      }\n      \n      extract_tags_as_vector <- function(x){\n        result <- unlist(str_extract_all(x, \"\\\\[[^\\\\[]*\\\\]\"))\n        result <- paste0(\"\", result)\n        result <- as.vector(result)\n        return(result)\n      }\n      \n      extract_comments_as_string <- function(x){\n        result <- unlist(str_extract_all(x, \"[\\x28][^\\x28|\\x29]*[\\x29]\"))\n        result <- paste0(\"\", result, collapse = \"\")\n        return(result)\n      }\n      \n      extract_tags_as_string <- function(x){\n        result <- unlist(str_extract_all(x, \"\\\\[[^\\\\[]*\\\\]\"))\n        result <- paste0(\"\", result, collapse = \"\")\n        return(result)\n      }\n      \n      replace_comments <- function(x){\n        result <- str_replace_all(x, \"[\\x28][^\\x28|\\x29]*[\\x29]\", \"\\x28\")\n        return(result)\n      }\n      \n      replace_tags <- function(x){\n        result <- str_replace_all(x, \"\\\\[[^\\\\[]*\\\\]\", \"\\\\[\")\n        return(result)\n      }\n      \n      insert_comments <- function(x, y){ ## Doesn't work\n        y <- str_replace_all(y, \"[\\x28]\", \"OPENBRACKETHERE\")\n        y <- str_replace_all(y, \"[\\x29]\", \"CLOSEDBRACKETHERE\")\n        for(i in 1:length(y)){\n          x <- str_replace(x, \"[\\x28]\", y[i])\n        }\n        x <- str_replace_all(x, \"OPENBRACKETHERE\",\"\\x28\")\n        x <- str_replace_all(x, \"CLOSEDBRACKETHERE\", \"\\x29\")\n        return(x)\n      }\n      \n      insert_tags <- function(x, y){ ## x = string, y = vector\n        y <- str_replace_all(y, \"\\\\[\", \"OPENBRACKETHERE\")\n        y <- str_replace_all(y, \"\\\\]\", \"CLOSEDBRACKETHERE\")\n        for(i in 1:length(y)){\n          x <- str_replace(x, \"\\\\[\", y[i])\n        }\n        x <- str_replace_all(x, \"OPENBRACKETHERE\",\"\\\\[\")\n        x <- str_replace_all(x, \"CLOSEDBRACKETHERE\", \"\\\\]\")\n        return(x)\n      }\n      \n      \n      remove_comments <- function(str){\n        str <- str_replace_all(str, \"[\\x28][^\\x28]*[\\x29]\", \"\")\n        return(str)\n      }\n      \n      remove_tags <- function(str){\n        str <- str_replace_all(str, \"\\\\[[^\\\\[]*\\\\]\", \"\")\n        return(str)\n      }\n      \n      \n      identify_words_containing_punct <- function(vec){\n        \n        result = rep(\"\", length(vec))\n        \n        for(i in 1:length(vec)){\n          result[i] = paste(unlist(str_extract_all(vec[i], \"[^\\x20]+[:punct:][^\\x20]+\")), collapse = \" \")\n        }\n        \n        return(result)\n      }\n      \n      \n      Num_Words <- count_words_using_spaces(remove_non_alphanumeric(remove_comments(remove_tags(text$text))))\n      \n      morph_complex_words = identify_words_containing_punct(remove_comments(remove_tags(text$text)))\n      \n      text$comments <- sapply(text$text, extract_comments_as_string)\n      \n      text$tags <- sapply(text$text, extract_tags_as_string)\n      \n      comments <- text$comments\n      tags <- text$tags\n      \n      text$text <- replace_comments(text$text)\n      text$text <- replace_tags(text$text)\n      \n      text_comments_extracted <- gsub(\"\\\\[\", \"\", text$text)\n      text_comments_extracted <- gsub(\"\\\\(\", \"\", text_comments_extracted)\n      \n      has_period <- function(x){\n        return(grepl(\"[\\x2e]\", x))\n      }\n      \n      has_question_mark <- function(x){\n        return(grepl(\"[\\x3f]\", x))\n      }\n      \n      has_single_exclamation_mark <- function(x){\n        return(str_count(x, \"[\\x21]\") == 1)\n      }\n      \n      has_multiple_exclamation_marks <- function(x){\n        return(str_count(x, \"[\\x21]\") >= 2)\n      }\n      \n      text$mood <- \"\"\n      \n      text$mood[has_period(text$text)] <- \"isdeclarative\"\n      text$mood[has_question_mark(text$text)] <- \"isinterrogative isquestion\"\n      text$mood[has_single_exclamation_mark(text$text)] <- \"isimperative\"\n      text$mood[has_multiple_exclamation_marks(text$text)] <- \"isexclamative\"\n      \n      mood <- text$mood\n      \n      # Download language model and parse text\n      \n      if(input$manual_url==\"\"){\n        model <- udpipe_download_model(lang, model_dir = tempdir()) # NB can add \"model_dir = tempdir()\"\n      }\n      \n      if(input$manual_url!=\"\"){\n        model <- udpipe_download_model(input$manual_url, model_dir = tempdir())\n      }\n      \n      \n      model <- udpipe_load_model(model$file_model)\n      \n      # browser(); one <- 1; one <- 1; one <- 1; one <- 1; one< -1\n      \n      text <- udpipe_annotate(model, text$text)\n      \n      text <- as.data.frame(text)\n      \n      \n      text$morpheme <- 1\n      text$morpheme[which(text$upos == \"PUNCT\")] <- 0 # So we don't count punctuation as a morpheme\n      \n      \n      text$upos[which(text$dep_rel == \"cop\")] <- \"COPULA\"\n      \n      # Identify number of clauses\n      \n      text$num_clause <- as.numeric(text$upos == \"VERB\" | text$upos == \"COPULA\")\n      \n      text$num_fin_clause <- as.numeric(grepl(\"VerbForm=Fin\", text$feats))\n      \n      verb_form <- function(x){\n        return(\n          case_when(\n            grepl(\"Tense=Past[\\x7c]VerbForm=Fin\",x) == TRUE ~ \"hasPastTense\",\n            grepl(\"Tense=Pres[\\x7c]VerbForm=Fin\", x) == TRUE ~ \"hasPresTense hasPresentTense\",\n            grepl(\"Tense=Past[\\x7c]VerbForm=Part\", x) == TRUE ~ \"hasPastParticiple\",\n            grepl(\"Tense=Pres[\\x7c]VerbForm=Part\", x) == TRUE ~ \"hasPresentParticiple hasPresParticiple\",\n            grepl(\"VerbForm=Inf\", x) == TRUE ~ \"hasInfinitive\",\n            TRUE ~ \"\"\n          )\n        )\n      }\n      \n      \n      text$verb_form <- sapply(text$feats, verb_form)\n      \n      rel_clause <- function(x){\n        return(\n          case_when(\n            grepl(\"relcl\", x) == TRUE ~ \"hasRelativeClause\",\n            TRUE ~ \"\"\n          )\n        )\n      }\n      \n      text$rel_clause <- sapply(text$dep_rel, rel_clause)\n      \n      \n      highlight <- function(text, colour){ # highlights text in a particular colour\n        result <- paste0(\"<span style=\\\"background-color:\", colour, \";\\\">\",\n                         \"&thinsp;\", text, \"&thinsp;\",\n                         \"<\/span>\")\n        return(result)\n      }\n      \n      text$features_coloured <- paste0(highlight(text$dep_rel, \"#cc99ff\"), # Violet\n                                       highlight(text$token, \"#ff6666\"), # Orange\n                                       highlight(text$upos, \"#ffc299\"), # Green\n                                       highlight(text$xpos, \"#9999ff\"), # Dark blue\n                                       highlight(text$feats, \"#c68c53\"), # Brown\n                                       \" \"\n      )\n      \n      text$features <- paste0(text$dep_rel, \"-\",\n                              text$token, \"-\",\n                              text$upos, \"-\",\n                              text$xpos, \"-\",\n                              text$feats, \" \"\n      )\n      \n      \n      add_tool_tip <- function(text, label){\n        result <- paste0(\"<div class=\\\"mytooltip\\\">\",\n                         text,\n                         \"<span class=\\\"tooltiptext\\\">\",\n                         label,\n                         \"<\/span>\",\n                         \"<\/div>\")\n        return(result)\n      }\n      \n      add_tool_tip_reduced_text <- function(text, label){\n        result <- paste0(\"<div class=\\\"mytooltip\\\">\",\n                         paste0(substr(text, 1, 15), \"...\"),\n                         \"<span class=\\\"tooltiptext\\\">\",\n                         label,\n                         \"<\/span>\",\n                         \"<\/div>\")\n        return(result)\n      }\n      \n      \n      if(is.null(input$VERB_colour)) {VERB_colour <- \"#FFAB94\"} else {VERB_colour <- input$VERB_colour}\n      if(is.null(input$COPULA_colour)) {COPULA_colour <- \"#FFAB94\"} else {COPULA_colour <- input$COPULA_colour}\n      if(is.null(input$AUXILIARY_colour)) {AUXILIARY_colour <- \"#FAD4CB\"} else {AUXILIARY_colour <- input$AUXILIARY_colour}\n      if(is.null(input$PARTICLE_colour)) {PARTICLE_colour <- \"#FAD4CB\"} else {PARTICLE_colour <- input$PARTICLE_colour}\n      if(is.null(input$ADVB_colour)) {ADVB_colour <- \"#FAD4CB\"} else {ADVB_colour <- input$ADVB_colour}\n      if(is.null(input$NOUN_colour)) {NOUN_colour <- \"#B6B6F5\"} else {NOUN_colour <- input$NOUN_colour}\n      if(is.null(input$DET_colour)) {DET_colour <- \"#ADFFFF\"} else {DET_colour <- input$DET_colour}\n      if(is.null(input$ADJ_colour)) {ADJ_colour <- \"#ADFFFF\"} else {ADJ_colour <- input$ADJ_colour}\n      if(is.null(input$PRON_colour)) {PRON_colour <- \"#99FF69\"} else {PRON_colour <- input$PRON_colour}\n      if(is.null(input$PREP_colour)) {PREP_colour <- \"#FFFF52\"} else {PREP_colour <- input$PREP_colour}\n      if(is.null(input$SUB_colour)) {SUB_colour <- \"#FCAD46\"} else {SUB_colour <- input$SUB_colour}\n      if(is.null(input$COORD_colour)) {COORD_colour <- \"#FFCD7D\"} else {COORD_colour <- input$COORD_colour}\n      if(is.null(input$PUNCT_colour)) {PUNCT_colour <- \"#eeeedd\"} else {PUNCT_colour <- input$PUNCT_colour}\n      if(is.null(input$INTERJECTION_colour)) {INTERJECTION_colour <- \"#C29A72\"} else {INTERJECTION_colour <- input$INTERJECTION_colour}\n      \n      \n      highlight_wc <- function(string, wc){\n        if(is.na(wc)){return(string)}\n        # red (original colours - user may change)\n        else if(wc == \"VERB\"){result <- add_tool_tip(highlight(paste0(\"<b>\",string,\"<\/b>\"), VERB_colour), \"VERB\")}\n        else if(wc == \"COPULA\"){result <- add_tool_tip(highlight(paste0(\"<b>\", string, \"<\/b>\"), COPULA_colour), \"COPULA\")}\n        # orange\n        else if(wc == \"SCONJ\"){result <- add_tool_tip(highlight(string, SUB_colour), \"SCONJ.\")}\n        # light orange\n        else if(wc == \"CCONJ\"){result <- add_tool_tip(highlight(string, COORD_colour), \"CCONJ.\")}\n        # green\n        else if(wc == \"PRON\"){result <- add_tool_tip(highlight(string, PRON_colour), \"PRON.\")}\n        # pink\n        else if(wc == \"AUX\"){result <- add_tool_tip(highlight(string, AUXILIARY_colour), \"AUX.\")}\n        else if(wc == \"ADV\"){result <- add_tool_tip(highlight(string, ADVB_colour), \"ADV.\")}\n        else if(wc == \"PART\"){result <- add_tool_tip(highlight(string, PARTICLE_colour), \"PARTICLE\")}\n        # dark blue\n        else if(wc == \"NOUN\"){result <- add_tool_tip(highlight(string, NOUN_colour), \"NOUN\")}\n        else if(wc == \"PROPN\"){result <- add_tool_tip(highlight(string, NOUN_colour), \"PROPN\")}\n        # cyan\n        else if(wc == \"DET\"){result <- add_tool_tip(highlight(string, DET_colour), \"DET.\")}\n        else if(wc == \"DET.poss\"){result <- add_tool_tip(highlight(string, DET_colour), \"DET.poss\")}\n        else if(wc == \"ADJ\"){result <- add_tool_tip(highlight(string, ADJ_colour), \"ADJ.\")}\n        else if(wc == \"NUM\"){result <- add_tool_tip(highlight(string, DET_colour), \"NUM.\")}\n        # brown\n        else if(wc == \"INTJ\"){result <- add_tool_tip(highlight(string, INTERJECTION_colour), \"INTJ\")}\n        # yellow\n        else if(wc == \"ADP\"){result <- add_tool_tip(highlight(string, PREP_colour), \"PREP.\")}\n        # grey\n        else if(wc == \"PUNCT\"){result <- add_tool_tip(highlight(string, PUNCT_colour), \"PUNCT.\")}\n        else if(wc == \"X\"){result <- add_tool_tip(highlight(string, \"#b8b894\"), \"X\")}\n        else if(wc == \"SYM\"){result <- add_tool_tip(highlight(string, \"#b8b894\"), \"SYM\")}\n        else{result <- string}\n        return(result)\n      }\n      \n      \n      \n      text %>% filter(!is.na(upos)) -> text\n      \n      text$coloured <- mapply(highlight_wc, text$token, text$upos) # Applies html formatting to tokens\n      \n      # Create placemarkers used for inserting comments and tags back into text\n      text$coloured[which(text$token == \"(\")] <- \"(\"\n      text$coloured[which(text$token == \"[\")] <- \"[\"\n      \n      # create variable showing line of text\n      text$line <- NULL\n      get_doc_number <- function(x){\n        return(as.numeric(substr(x, 4, nchar(x))))\n      }\n      text$line <- sapply(text$doc, get_doc_number)\n      \n      # create variable which will allow user to search for word by class\n      \n      text$upos[which(text$upos == \"ADP\")] <- \"PREP\"\n      text$hasclass <- paste0(\"has\", tolower(text$upos))\n      \n      text$neg <- \"\"\n      text$neg[which(grepl(\"not\", text$token))] <- \"hasneg\"\n      text$neg[which(grepl(\"n't\", text$token))] <- \"hasneg\"\n      \n      # Reshape data\n      text %>%\n        group_by(line) %>%\n        summarise(sentence_coloured = paste(coloured, collapse = \" \"),\n                  sentence = paste(token, collapse = \" \"),\n                  features_coloured = paste(features_coloured, collapse = \" \"),\n                  features = paste(features, collapse = \" \"),\n                  has_class = paste(hasclass, collapse = \" \"),\n                  pos_tags = paste(upos, collapse = \" \"),\n                  neg = paste(neg, collapse = \" \"),\n                  `Num Morphs` = sum(morpheme),\n                  num_clause = sum(num_clause),\n                  num_fin_clause = sum(num_fin_clause),\n                  verb_form = paste(verb_form, collapse = \" \"),\n                  rel_clause = paste(rel_clause, collapse = \" \")\n        ) -> text\n      \n      \n      text$`Morph Complex Words` = morph_complex_words\n      \n      if(lang == \"english\"){ # English labelling rules ----\n        \n        extract_word_from_features = function(x){\n          if(length(x) == 0){\n            return(\"\")\n          }\n          else(return(unlist(strsplit(x, \"-\"))[2]))\n        }\n        \n        regular_plural_nouns_all_features = str_extract_all(text$features, \"[^\\x20]*s-NOUN-NNS-Number=Plur[^\\x20]*\")\n        regular_past_tense_verbs_all_features = str_extract_all(text$features, \"[^\\x20]*ed-VERB-VBD-Mood=Ind[\\x7c]Tense=Past[\\x7c]VerbForm=Fin[^\\x20]*\")\n        regular_perfective_verbs_all_features = str_extract_all(text$features, \"[^\\x20]*ed-VERB-VBN-Tense=Past[\\x7c]VerbForm=Part[^\\x20]*\")\n        progressive_verbs_all_features = str_extract_all(text$features, \"[^\\x20]*ing-VERB-VBG-Tense=Pres[\\x7c]VerbForm=Part[^\\x20]*\")\n        \n        \n        text$`Num Morphs` = text$`Num Morphs` +\n          lengths(regular_plural_nouns_all_features) +\n          lengths(regular_past_tense_verbs_all_features) +\n          lengths(regular_perfective_verbs_all_features) +\n          lengths(progressive_verbs_all_features)\n        \n        morph_complex_words_to_add = rep(\"\", length(text$`Num Morphs`))\n        \n        for(i in 1:length(text$`Num Morphs`)){\n          morph_complex_words_to_add[i] = c(\n            paste(\n              paste(sapply(unlist(regular_plural_nouns_all_features[i]), extract_word_from_features), collapse = \" \"),\n              paste(sapply(unlist(regular_past_tense_verbs_all_features[i]), extract_word_from_features), collapse = \" \"),\n              paste(sapply(unlist(regular_perfective_verbs_all_features[i]), extract_word_from_features), collapse = \" \"),\n              paste(sapply(unlist(progressive_verbs_all_features[i]), extract_word_from_features), collapse = \" \"),\n              collapse = \" \")\n          )\n        }\n        \n        text$`Morph Complex Words` = paste(text$`Morph Complex Words`, morph_complex_words_to_add)\n        \n      }\n      \n      \n      text$NPexpansion <- \"\"\n      \n      text$NPexpansion[grepl(\"((DET|DET\\x2eposs|ADJ|NUM)\\x20)+(NOUN|PROPN)\", text$pos_tags)] <- \"hasNPexpansion\"\n      \n      text$VCexpansion <- \"\"\n      \n      text$VCexpansion[grepl(\"((AUX|ADV|VERB|PART)\\x20)+(VERB)\", text$pos_tags)] <- \"hasVCexpansion hasVPexpansion\"\n      \n      text$clause2 <- \"\"\n      text$multipleclauses <- \"\"\n      text$clause3 <- \"\"\n      text$clause4 <- \"\"\n      text$clause5 <- \"\"\n      \n      text$clause2[which(text$num_fin_clause == 2)] <- \"has2clauses\"\n      text$multipleclauses[which(text$num_fin_clause >= 2)] <- \"hasmultipleclauses, iscomplex\"\n      text$clause3[which(text$num_fin_clause == 3)] <- \"has3clauses\"\n      text$clause4[which(text$num_fin_clause == 4)] <- \"has4clauses\"\n      text$clause5[which(text$num_fin_clause == 5)] <- \"has5clauses\"\n      \n      # This section has functions to colour comments and tags. The comments and tags are then\n      # inserted back into the sentence_coloured variable, and coloured accordingly\n      \n      colour_comments <- function(x){\n        result <- str_replace_all(x, \"[\\x28]\", \"<span style=\\\"color:#333399;\\\">(\")\n        result <- str_replace_all(result, \"[\\x29]\", \")<\/span>\")\n        return(result)\n      }\n      \n      colour_tags <- function(x){\n        result <- str_replace_all(x, \"\\\\[\", \"<span style=\\\"color:#992600;\\\">\\\\[\")\n        result <- str_replace_all(result, \"\\\\]\", \"\\\\]<\/span>\")\n        return(result)\n      }\n      \n      for(i in 1:nrow(text)){\n        \n        text$sentence_coloured[i] <- colour_comments(insert_comments(text$sentence_coloured[i],\n                                                                     extract_comments_as_vector(comments[i])))\n        \n        text$sentence_coloured[i] <- colour_tags(insert_tags(text$sentence_coloured[i],\n                                                             extract_tags_as_vector(tags[i])))\n      }\n      \n      text$speaker <- speakers\n      text$speaker_no_html <- speakers\n      \n      unique_speakers <- unique(speakers)\n      unique_speakers <- unique_speakers[which(unique_speakers != \"\")]\n      \n      speaker_colours <- c(\"#f2ffe6\", \"#ffddcc\", \"#e6f7ff\", \"#ffe6ff\",\n                           \"#ffffcc\", \"#ffe6ff\", \"#ccddff\", \"#ffcce0\",\n                           \"#ccccff\", \"#ff0000\", \"#81a375\", \"\t#ccffcc\")\n      \n      speaker_colours <- c(speaker_colours, rep(\"#ffffff\", 100)) # just in case there are lots of speakers!\n      \n      for(i in 1:nrow(text)){\n        text$speaker[i] <- highlight(text$speaker[i],\n                                     speaker_colours[which(unique_speakers == text$speaker[i])])\n        \n      }\n      \n      text$mood <- mood\n      \n      text$passive <- \"\"\n      text$passive[which(grepl(\"Voice=Pass\", text$features))] <- \"haspassive\"\n      \n      text$relativepronoun <- \"\"\n      text$relativepronoun[which(grepl(\"PronType=Rel\", text$features))] <- \"hasrelativepronoun\"\n      \n      text$modal <- \"\"\n      text$modal[which(grepl(\"MD\", text$features))] <- \"hasmodalverb\"\n      \n      text$speaker[which(text$`Num Morphs`==0)] <- \"\"\n      text$speaker_no_html[which(text$`Num Morphs`==0)] <- \"\"\n      \n      text$`Num Words` <- Num_Words\n      \n      text$text_comments_extracted <- text_comments_extracted\n      \n      # Create variable to allow user to identify lines with comments or tags\n      hascomment <- rep(\"\", length(comments))\n      hascomment[which(comments!=\"\")] <- \"hascomment\"\n      text$hascomment <- hascomment\n      \n      hastag <- rep(\"\", length(tags))\n      hastag[which(tags!=\"\")] <- \"hastag\"\n      text$hastag <- hastag\n      \n      # Create a column to allow user to search for specific tags\n      tags_plus_content <- str_replace_all(tags, \"\\x20\", \"\") #remove gaps\n      tags_plus_content <- str_replace_all(tags_plus_content, \"\\\\[\", \"hastag\") #start with \"hastag\"\n      tags_plus_content <- str_trim(str_replace_all(tags_plus_content, \"\\\\]\", \"\\x20\")) #remove final brackets\n      text$tags_plus_content <- tags_plus_content # create variable\n      text$tags <- tags\n      \n      # Code produces position_within_turn and turn_length variables.\n      \n      text$new_turn <- 0\n      speaker <- \"\"\n      \n      for(i in 1:nrow(text)){\n        if(text$speaker[i] != \"\" & text$speaker[i] != speaker){text$new_turn[i] <- 1}\n        if(text$speaker[i] != \"\" & text$speaker[i] != speaker){speaker <- text$speaker[i]}\n      }\n      \n      text$position_within_turn <- NA\n      position_within_turn <- 1\n      \n      for(i in 1:nrow(text)){\n        if(text$new_turn[i] == 1){position_within_turn <- 0}\n        if(text$speaker[i] != \"\"){position_within_turn <- position_within_turn + 1}\n        text$position_within_turn[i] <- position_within_turn\n      }\n      \n      text$position_within_turn[which(text$speaker == \"\")] <- 0\n      \n      text$turn_length <- NA\n      top <- 0\n      \n      for(i in nrow(text):1){\n        \n        top <- max(top, text$position_within_turn[i])\n        text$turn_length[i] <- top\n        if(text$position_within_turn[i] == 1){top <- 0}\n      }\n      \n      text$turn_length_string <- paste0(\"turn\", text$turn_length)\n      text$turn_length_string[which(text$turn_length == 0)] <- \"\"\n      text$turn_length_string[which(text$turn_length == 5)] <- \"turn5, turn5plus\"\n      text$turn_length_string[which(text$turn_length >= 6)] <- \"turn5plus\"\n      \n      text$turn_length_first_turn <- NA\n      \n      text$turn_length_first_turn[which(text$new_turn == 1)] <- text$turn_length[which(text$new_turn == 1)]\n      \n      text %>% select(line, speaker, sentence_coloured,\n                      `Num Words`, `Num Morphs`,\n                      num_clause, num_fin_clause, turn_length,\n                      `Morph Complex Words`, # here comes the line\n                      hascomment, hastag, tags_plus_content, tags,\n                      mood, neg, verb_form,\n                      NPexpansion, VCexpansion,\n                      has_class,\n                      clause2, clause3, clause4, clause4, multipleclauses,\n                      passive, relativepronoun, rel_clause, modal, text_comments_extracted,\n                      new_turn, position_within_turn, turn_length, turn_length_string, turn_length_first_turn,\n                      features_coloured, features, speaker_no_html) -> text\n      \n      \n      return(text)\n    })\n    \n    \n    \n    \n    # table_lex (HDD etc) ----\n    table_lex <- reactive({\n      \n      df <- table()\n      df %>% group_by(speaker, speaker_no_html) %>% filter(speaker != \"\") %>%\n        summarise(lex = paste(text_comments_extracted, collapse = \" \")) -> df\n      \n      df$hdd <- as.numeric(NA)\n      df$ttr <- as.numeric(NA)\n      \n      for(i in 1:nrow(df)){\n        corpus <- koRpus::tokenize(df$lex[i], lang = \"en\", format = \"obj\")\n        hdd <- HDD(corpus)\n        ttr <- TTR(corpus)\n        df$types[i] <- length(types(corpus))\n        df$tokens[i] <- length(tokens(corpus))\n        df$hdd[i] <- as.numeric(koRpus::summary(hdd)[2])\n        df$ttr[i] <- as.numeric(koRpus::summary(ttr)[2])\n      }\n      \n      return(df)\n    })\n    \n    \n    output$text_example <- renderUI({\n      text <- substr(text(), 1, 1000)\n      HTML(paste0(\"<p><h1>Text<\/h1><h3>(up to 1000th character)<\/h3>\", text,\"<\/p> <p><h2>Language detected: \",\n                  \"<strong><span style=\\\"background-color:#00ffff;\\\">\",\n                  lang(),\n                  \"<\/style><\/h2><\/p>\"))\n    })\n    \n    search_options = c(\"hasNoun\",\n                       \"hasPronoun\",\n                       \"hasVerb\",\n                       \"hasAux\",\n                       \"hasModalVerb\",\n                       \"hasAdjective\",\n                       \"hasAdverb\",\n                       \"hasPreposition\",\n                       \"hasPron\",\n                       \"hasCConj\",\n                       \"hasSConj\",\n                       \"hasNeg\",\n                       \"hasNum\",\n                       \"hasPastTense\",\n                       \"hasPresTense\",\n                       \"hasCopula\",\n                       \"hasPresParticiple\",\n                       \"hasPerfParticiple\",\n                       \"has2clauses\", \"has3clauses\", \"has4clauses\", \"has5clauses\", \"hasMultipleClauses\",\n                       \"hasPassive\", \"hasRelativePronoun\",\n                       \"isDeclarative\", \"isInterrogative\", \"isQuestion\", \"isImperative\", \"isExclamative\",\n                       \"hasComment\", \"hasTag\", \"hasTagContentsOfTagMinusSpaces\",\n                       \"turn1\", \"turn2\", \"turn3\", \"turn4\", \"turn5\", \"turn5plus\")\n    \n    # table_coloured ----\n    output$table_coloured = DT::renderDataTable({\n      \n      table = table()\n      \n      datatable(table,\n                plugins = \"ellipsis\",\n                filter = c(\"top\"),\n                rownames = FALSE,\n                escape = FALSE,\n                options = list(\n                  dom = '<\"top\" pif>',\n                  dom = 'Bfrtip',\n                  initComplete = DT::JS(paste0(\"\n          function(settings, json) {\n            // Hide the default search input\n            $('.dataTables_filter input').hide();\n            \n            // Create selectize dropdown\n            var searchOptions = \", jsonlite::toJSON(search_options), \";\n            \n            // Create select element\n            var selectElement = $('<select id=\\\"custom-search\\\" multiple><\/select>');\n            \n            // Add options to select\n            searchOptions.forEach(function(option) {\n              selectElement.append('<option value=\\\"' + option + '\\\">' + option + '<\/option>');\n            });\n            \n            // Replace the search input with our select\n            $('.dataTables_filter').append(selectElement);\n            $('.dataTables_filter label').contents().first()[0].textContent = 'Search: ';\n            \n            // Initialize selectize\n            $('#custom-search').selectize({\n              plugins: ['remove_button'],\n              delimiter: ',',\n              persist: false,\n              create: true,\n              placeholder: 'Select search terms...',\n              onChange: function(values) {\n                // Perform the search\n                var searchTerm = values.join('|');\n                settings.oInstance.api().search(searchTerm, true, false).draw();\n              }\n            });\n          }\")),\n                  \n                  paging = FALSE, autoWidth = TRUE, searching = TRUE,\n                  search = list(regex = TRUE, scrollX = TRUE),\n                  columnDefs = list(\n                    list( # This is supposed to truncate content, but does not work\n                      targets = which(names(table())==\"Morph Complex Words\"),\n                      render = JS(\"$.fn.dataTable.render.ellipsis( 1, false )\")\n                    )\n                  )\n                )\n      ) %>% formatStyle(columns = c(2), width='800px') %>% \n        formatStyle(\"features_coloured\",\"white-space\"=\"nowrap\") %>%\n        formatStyle(\"tags_plus_content\",\"white-space\"=\"nowrap\") %>%\n        formatStyle(\"features\",\"white-space\"=\"nowrap\") %>%\n        formatStyle(\"sentence_coloured\",\"white-space\"=\"nowrap\") %>%\n        formatStyle(\"Morph Complex Words\",\"white-space\"=\"nowrap\") %>%\n        formatStyle(\"verb_form\", \"white-space\"=\"nowrap\") %>%\n        formatStyle(\"has_class\", \"white-space\"=\"nowrap\") %>%\n        formatStyle(\"neg\", \"white-space\"=\"nowrap\") %>%\n        formatStyle(\"text_comments_extracted\", \"white-space\"=\"nowrap\") %>%\n        formatStyle(\"rel_clause\", \"white-space\" = \"nowrap\") %>%\n        formatStyle(\"tags\", \"white-space\"=\"nowrap\") %>%\n        formatStyle(\"mood\", \"white-space\"=\"nowrap\") %>%\n        formatStyle(\"VCexpansion\", \"white-space\"=\"nowrap\") %>%\n        formatStyle(\"multipleclauses\", \"white-space\"=\"nowrap\") %>%\n        formatStyle(9, `border-right` = \"solid 2px\")\n    })\n    \n    \n    # table_coloured_reduced ----\n    output$table_coloured_reduced = DT::renderDataTable({\n      datatable(table() %>%\n                  select(speaker, sentence_coloured) %>%\n                  mutate(sentence_coloured = stringr::str_replace_all(string = sentence_coloured,\n                                                                      pattern = \"<div class=\\\"mytooltip\\\">\",\n                                                                      replacement = \"\")) %>%\n                  mutate(sentence_coloured = stringr::str_replace_all(string = sentence_coloured,\n                                                                      pattern = \"<\/div>\",\n                                                                      replacement = \"\")) %>%\n                  mutate(sentence_coloured = stringr::str_replace_all(string = sentence_coloured,\n                                                                      pattern = \"<span class=\\\"tooltiptext\\\">[^\\x20]+<\/span>\",\n                                                                      replacement = \"\"))\n                ,\n                filter = c(\"top\"),\n                selection = \"none\",\n                rownames = FALSE,\n                escape = FALSE,\n                options = list(paging = FALSE, autoWidth = TRUE, searching = TRUE,\n                               search = list(regex = TRUE, scrollX = TRUE)\n                )\n      ) %>% \n        formatStyle(\"sentence_coloured\",\"white-space\"=\"nowrap\")\n    }) \n    \n    \n    \n    # table_summaries (MLU etc)----\n    output$table_summaries = DT::renderDataTable({\n      \n      \n      datatable(table() %>% filter(speaker!=\"\") %>% group_by(speaker) %>%\n                  summarise(`NUtts` = n(),\n                            `MLU-w` = round(mean(`Num Words`), digits = 2),\n                            `MLU-m` = round(mean(`Num Morphs`), digits = 2),\n                            `MNumCl` = round(mean(num_clause), digits = 2),\n                            `MLT` = round(mean(turn_length_first_turn, na.rm = TRUE), digits = 2)),\n                rownames = FALSE,\n                escape = FALSE,\n                options = list(paging = FALSE, autoWidth = TRUE, searching = FALSE, dom = 'ft'\n                ),\n                caption = htmltools::tags$caption(\n                  style = 'caption-side: bottom; text-align: left;',\n                  'NUtts: Number of Utterances, \n                  MLU-w: Mean Length of Utterance in Words, \n                  MLU-m: Mean Length of Utterance in Morphemes, \n                  MNumCl: Mean Number of (finite) Clauses per utterance, \n                  MLT: Mean Length of Turn')\n      )\n      \n    })\n    \n    \n    \n    # table_summaries2 (diversity) ----\n    output$table_summaries2 = DT::renderDataTable({\n      datatable(table_lex() %>% filter(speaker!=\"\") %>% group_by(speaker) %>%\n                  summarise(`HDD` = round(mean(hdd), digits = 2),\n                            `TTR` = round(mean(ttr), digits = 2)),\n                # filter = c(\"top\"),\n                rownames = FALSE,\n                escape = FALSE,\n                options = list(paging = FALSE, autoWidth = TRUE, searching = FALSE, dom = 'ft'\n                ),\n                caption = htmltools::tags$caption(\n                  style = 'caption-side: bottom; text-align: left;',\n                  'HDD: Hypergeometric Distribution density (virtually identical to VocD), \n                  TTR: Type-Token Ratio')\n      ) \n    })\n    \n    # (4) tag_table  ----\n    output$tag_table_v1 = DT::renderDataTable({\n      \n      df = table()\n      tags = unique(df$tags)\n      tags =  unique(unlist(strsplit(tags, \"(?<=\\\\])\", perl = TRUE)))\n      # tags = unlist(str_replace_all(tags, \"[\\\\[\\\\]]\", \"\"))\n      speakers_list = df$speaker\n      \n      \n      for(i in 1:length(tags)){\n        if(i == 1) {\n          initial_vector =  stringr::str_count(df$tags, fixed(tags[i]))\n          tags_df = cbind.data.frame(initial_vector)\n        }\n        if(i > 1) {\n          new_vector = stringr::str_count(df$tags, fixed(tags[i]))\n          tags_df =cbind.data.frame(tags_df, new_vector)\n        }\n      }\n      \n      names(tags_df) = tags\n      tags_df$speakers = speakers_list\n      \n      tags_df %>% relocate(speakers) -> tags_df\n      \n      datatable(tags_df %>% filter(speakers!=\"\") %>%\n                  group_by(speakers) %>%\n                  summarize(across(where(is.numeric), ~ round(mean(.x, na.rm = TRUE), digits = 2))),\n                rownames = FALSE,\n                escape = FALSE,\n                options = list(paging = FALSE, autoWidth = TRUE, searching = FALSE, scrollX = TRUE, dom = 'ft')\n      )\n    })\n    \n    \n    output$tag_table_v2 = DT::renderDataTable({\n      \n      df = table()\n      tags = unique(df$tags)\n      tags =  unique(unlist(strsplit(tags, \"(?<=\\\\])\", perl = TRUE)))\n      # tags = unlist(str_replace_all(tags, \"[\\\\[\\\\]]\", \"\"))\n      speakers_list = df$speaker\n      \n      # browser()\n      \n      for(i in 1:length(tags)){\n        if(i == 1) {\n          initial_vector =  stringr::str_count(df$tags, fixed(tags[i]))\n          tags_df = cbind.data.frame(initial_vector)\n        }\n        if(i > 1) {\n          new_vector = stringr::str_count(df$tags, fixed(tags[i]))\n          tags_df =cbind.data.frame(tags_df, new_vector)\n        }\n      }\n      \n      names(tags_df) = tags\n      tags_df$speakers = speakers_list\n      \n      # browser()\n      \n      tags_df %>% relocate(speakers) -> tags_df\n      \n      # browser()\n      \n      tags_df %>% mutate(across(where(is.numeric), ~ifelse(.x >0, 1, 0))) -> df\n      \n      datatable(tags_df %>% filter(speakers!=\"\") %>%\n                  group_by(speakers) %>%\n                  summarize(across(where(is.numeric), ~ round(100*mean(.x, na.rm = TRUE),  digits = 2))),\n                rownames = FALSE,\n                escape = FALSE,\n                options = list(paging = FALSE, autoWidth = TRUE, searching = FALSE, dom = 'ft', scrollX = TRUE)\n      )\n    })\n    \n    \n    # colours ----\n    \n    verb_col <- reactive({\n      colour <- colours[1, as.numeric(input$colour_scheme)]\n      return(colour)\n    })\n    \n    copula_col <- reactive({\n      colour <- colours[2, as.numeric(input$colour_scheme)]\n      return(colour)\n    })\n    \n    auxiliary_col <- reactive({\n      colour <- colours[3, as.numeric(input$colour_scheme)]\n      return(colour)\n    })\n    \n    particle_col <- reactive({\n      colour <- colours[4, as.numeric(input$colour_scheme)]\n      return(colour)\n    })\n    \n    advb_col <- reactive({\n      colour <- colours[5, as.numeric(input$colour_scheme)]\n      return(colour)\n    })\n    \n    noun_col <- reactive({\n      colour <- colours[6, as.numeric(input$colour_scheme)]\n      return(colour)\n    })\n    \n    det_col <- reactive({\n      colour <- colours[7, as.numeric(input$colour_scheme)]\n      return(colour)\n    })\n    \n    adj_col <- reactive({\n      colour <- colours[8, as.numeric(input$colour_scheme)]\n      return(colour)\n    })\n    \n    pron_col <- reactive({\n      colour <- colours[9, as.numeric(input$colour_scheme)]\n      return(colour)\n    })\n    \n    prep_col <- reactive({\n      colour <- colours[10, as.numeric(input$colour_scheme)]\n      return(colour)\n    })\n    \n    sub_col <- reactive({\n      colour <- colours[11, as.numeric(input$colour_scheme)]\n      return(colour)\n    })\n    \n    coord_col <- reactive({\n      colour <- colours[12, as.numeric(input$colour_scheme)]\n      return(colour)\n    })\n    \n    punct_col <- reactive({\n      colour <- colours[13, as.numeric(input$colour_scheme)]\n      return(colour)\n    })\n    \n    interjection_col <- reactive({\n      colour <- colours[14, as.numeric(input$colour_scheme)]\n      return(colour)\n    })\n    \n    output$colour_picker_verb <- renderUI({\n      colourpicker::colourInput(\n        inputId = \"VERB_colour\",\n        label = \"Main Verb (label = VERB)\",\n        value = verb_col()\n      )\n    })\n    \n    output$colour_picker_copula <- renderUI({\n      colourpicker::colourInput(\n        inputId = \"COPULA_colour\",\n        label = \"Copula (label = COPULA)\",\n        value = copula_col()\n      )\n    })\n    \n    output$colour_picker_auxiliary <- renderUI({\n      colourpicker::colourInput(\n        inputId = \"AUXILIARY_colour\",\n        label = \"Auxiliary verb (label = AUXILIARY)\",\n        value = auxiliary_col()\n      )\n    })\n    \n    output$colour_picker_particle <- renderUI({\n      colourpicker::colourInput(\n        inputId = \"PARTICLE_colour\",\n        label = \"Verb particle (label = PARTICLE)\",\n        value = particle_col()\n      )\n    })\n    \n    output$colour_picker_advb <- renderUI({\n      colourpicker::colourInput(\n        inputId = \"ADVB_colour\",\n        label = \"Adverb (label = ADVB)\",\n        value = advb_col()\n      )\n    })\n    \n    output$colour_picker_noun <- renderUI({\n      colourpicker::colourInput(\n        inputId = \"NOUN_colour\",\n        label = \"Noun (label = NOUN)\",\n        value = noun_col()\n      )\n    })\n    \n    \n    output$colour_picker_det <- renderUI({\n      colourpicker::colourInput(\n        inputId = \"DET_colour\",\n        label = \"Determiner (label = DET)\",\n        value = det_col()\n      )\n    })\n    \n    \n    output$colour_picker_adj <- renderUI({\n      colourpicker::colourInput(\n        inputId = \"ADJ_colour\",\n        label = \"Adjective (label = ADJ)\",\n        value = adj_col()\n      )\n    })\n    \n    \n    output$colour_picker_pron <- renderUI({\n      colourpicker::colourInput(\n        inputId = \"PRON_colour\",\n        label = \"Pronoun (label = PRON)\",\n        value = pron_col()\n      )\n    })\n    \n    output$colour_picker_prep <- renderUI({\n      colourpicker::colourInput(\n        inputId = \"PREP_colour\",\n        label = \"Preposition (label = PREP)\",\n        value = prep_col()\n      )\n    })\n    \n    output$colour_picker_sub <- renderUI({\n      colourpicker::colourInput(\n        inputId = \"SUB_colour\",\n        label = \"Subordinator (label = SUB)\",\n        value = sub_col()\n      )\n    })\n    \n    output$colour_picker_coord <- renderUI({\n      colourpicker::colourInput(\n        inputId = \"COORD_colour\",\n        label = \"Coordinator (label = COORD)\",\n        value = coord_col()\n      )\n    })\n    \n    output$colour_picker_punct <- renderUI({\n      colourpicker::colourInput(\n        inputId = \"PUNCT_colour\",\n        label = \"Punctuation (label = PUNCT)\",\n        value = punct_col()\n      )\n    })\n    \n    output$colour_picker_interjection <- renderUI({\n      colourpicker::colourInput(\n        inputId = \"INTERJECTION_colour\",\n        label = \"Interjection (label = INTERJECTION)\",\n        value = interjection_col()\n      )\n    })\n    \n  }\n  \n)\n\nshinyApp(ui = ui, server = server)\n\n\n\n","type":"text"},{"name":"MiMo - WebR - Export.Rproj","content":"Version: 1.0\n\nRestoreWorkspace: Default\nSaveWorkspace: Default\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nUseSpacesForTab: Yes\nNumSpacesForTab: 2\nEncoding: UTF-8\n\nRnwWeave: Sweave\nLaTeX: pdfLaTeX\n","type":"text"}]
